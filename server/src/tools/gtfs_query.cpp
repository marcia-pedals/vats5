#include <CLI/CLI.hpp>
#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "gtfs/gtfs.h"
#include "gtfs/gtfs_filter.h"

using namespace vats5;

void QueryStops(const GtfsDay& data) {
  for (const auto& stop : data.stops) {
    std::cout << stop.stop_id.v << "\t" << stop.stop_name << std::endl;
  }
}

void QueryRoutes(const GtfsDay& data) {
  std::unordered_map<GtfsRouteId, std::vector<const GtfsDirection*>> dir_map;
  for (const auto& dir : data.directions) {
    dir_map[dir.route_direction_id.route_id].push_back(&dir);
  }

  for (const auto& route : data.routes) {
    std::cout << route.route_id.v << "\t" << route.route_short_name << "\t"
              << route.route_long_name << std::endl;
    auto it = dir_map.find(route.route_id);
    if (it != dir_map.end()) {
      for (const auto* dir : it->second) {
        std::cout << "  direction " << dir->route_direction_id.direction_id
                  << ": " << dir->direction << std::endl;
      }
    }
  }
}

void QueryRequiredStopsConfig(
    const GtfsDay& data,
    int argc,
    char* argv[]
) {
  // Build a map of stop_id to stop_name
  std::unordered_map<GtfsStopId, std::string> stop_names;
  for (const auto& stop : data.stops) {
    stop_names[stop.stop_id] = stop.stop_name;
  }

  // Collect all unique stop IDs from the filtered data
  std::unordered_set<GtfsStopId> stop_ids;
  for (const auto& stop_time : data.stop_times) {
    stop_ids.insert(stop_time.stop_id);
  }

  // Convert to sorted vector, sorted by stop name
  std::vector<GtfsStopId> sorted_stops(stop_ids.begin(), stop_ids.end());
  std::sort(sorted_stops.begin(), sorted_stops.end(),
            [&stop_names](const GtfsStopId& a, const GtfsStopId& b) {
              return stop_names[a] < stop_names[b];
            });

  // Output the TOML file with original command
  std::cout << "# Generated by: gtfs_query";
  for (int i = 1; i < argc; ++i) {
    std::cout << " " << argv[i];
  }
  std::cout << "\n\nstop_ids = [\n";

  for (const auto& stop_id : sorted_stops) {
    std::cout << "  \"" << stop_id.v << "\", # " << stop_names[stop_id] << "\n";
  }

  std::cout << "]\n";
}

int main(int argc, char* argv[]) {
  CLI::App app{"Query filtered GTFS data"};

  std::string config_path;
  std::string command;
  std::string trip_id_prefix;
  std::string route_ids;

  app.add_option("config_path", config_path, "Path to TOML config file")
      ->required();
  app.add_option("command", command,
                 "Query command (stops, routes, required_stops_config)")
      ->required();
  app.add_option("--trip_id_prefix", trip_id_prefix,
                 "Comma-separated list of trip ID prefixes to filter by");
  app.add_option("--route_ids", route_ids,
                 "Comma-separated list of exact route IDs to include");

  CLI11_PARSE(app, argc, argv);

  try {
    GtfsFilterConfig config = GtfsFilterConfigLoad(config_path);
    GtfsDay data = GtfsNormalizeStops(GtfsFilterFromConfig(config));

    if (!trip_id_prefix.empty()) {
      std::vector<std::string> prefixes;
      std::istringstream ss(trip_id_prefix);
      std::string prefix;
      while (std::getline(ss, prefix, ',')) {
        prefixes.push_back(prefix);
      }

      std::unordered_set<GtfsTripId> matching_trips;
      for (const auto& trip : data.trips) {
        for (const auto& p : prefixes) {
          if (trip.trip_id.v.substr(0, p.length()) == p) {
            matching_trips.insert(trip.trip_id);
            break;
          }
        }
      }
      data = GtfsDayFilterByTrips(data, matching_trips);
      RemoveUnreferencedTripsRoutesAndDirections(data);
    }

    if (!route_ids.empty()) {
      std::unordered_set<GtfsRouteId> route_id_set;
      std::istringstream ss(route_ids);
      std::string id;
      while (std::getline(ss, id, ',')) {
        route_id_set.insert(GtfsRouteId{id});
      }

      std::unordered_set<GtfsTripId> matching_trips;
      for (const auto& trip : data.trips) {
        if (route_id_set.count(trip.route_direction_id.route_id)) {
          matching_trips.insert(trip.trip_id);
        }
      }
      data = GtfsDayFilterByTrips(data, matching_trips);
      RemoveUnreferencedTripsRoutesAndDirections(data);
    }

    if (command == "stops") {
      QueryStops(data);
    } else if (command == "routes") {
      QueryRoutes(data);
    } else if (command == "required_stops_config") {
      QueryRequiredStopsConfig(data, argc, argv);
    } else {
      std::cerr << "Unknown command: " << command << std::endl;
      std::cerr << "Available commands: stops, routes, required_stops_config"
                << std::endl;
      return 1;
    }
  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }

  return 0;
}
